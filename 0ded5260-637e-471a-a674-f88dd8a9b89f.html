<!DOCTYPE html>
<html>

<head>
  <style>
    /* Global black color override for non-auto-contrast elements */
    *:not(.auto-contrast-text) {
      color: rgb(0, 0, 0) !important;
    }

    html {
      height: 100%;
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, 'Segoe UI Variable Display', 'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji', 'Segoe UI Symbol';
    }

    body {
      /* background-color: rgb(25, 25, 25); */
      background-color: transparent;
      margin: 0;
      padding: 0px;
    }

    .feedback-widget {
      display: inline-flex;
      align-items: center;
      padding: 0px 12px 0px 0px;
    }

    /* Ensure auto-contrast text color overrides take precedence */
    .auto-contrast-text,
    .auto-contrast-text * {
      color: inherit !important;
      font-weight: 500;
    }

    /* Notion theme support - try to inherit theme colors if available */
    .notion-theme-aware {
      background-color: var(--notion-bg-color, var(--notion-theme-bg, inherit));
      color: var(--notion-text-color, var(--notion-theme-text, inherit));
    }

    /* Enhanced auto-contrast with Notion theme fallbacks */
    .auto-contrast-text.notion-enhanced {
      /* Use Notion theme colors if available, fallback to auto-calculation */
      color: var(--notion-auto-text-color, inherit);
    }
  </style>
</head>

<body class="page-body ">
  <div class="feedback-widget auto-contrast-text notion-enhanced">
    <span>Just let me know if you think this is helpful.</span>
    <span data-lyket-type="like" data-lyket-id="0ded5260-637e-471a-a674-f88dd8a9b89f" data-lyket-namespace="notion"
      data-lyket-template="twitter"></span>
  </div>
  <script src="https://unpkg.com/@lyket/widget@latest/dist/lyket.js?apiKey=pt_c791403c654b27c63cd0926a8d1f37"></script>

  <script>
    // Enhanced function to parse any CSS color format to RGB
    function parseColorToRgb(color) {
      if (!color || color === 'transparent' || color === 'rgba(0, 0, 0, 0)') return null;
      
      // Create a temporary element to get computed style
      var tempDiv = document.createElement('div');
      tempDiv.style.color = color;
      tempDiv.style.display = 'none';
      document.body.appendChild(tempDiv);
      var computedColor = window.getComputedStyle(tempDiv).color;
      document.body.removeChild(tempDiv);

      // Parse RGB values - handle both rgb() and rgba() formats
      var rgbMatch = computedColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      
      // Handle hex colors, named colors, etc. that computed style returns as rgb
      if (computedColor.startsWith('rgb')) {
        rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          return {
            r: parseInt(rgbMatch[1]),
            g: parseInt(rgbMatch[2]),
            b: parseInt(rgbMatch[3])
          };
        }
      }
      
      return null;
    }

    // Enhanced function to calculate if a color is light or dark with better algorithm
    function getContrastYIQ(r, g, b) {
      // YIQ formula for luminance (more accurate than simple average)
      var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      return (yiq >= 128) ? 'light' : 'dark';
    }

    // Calculate optimal text color based on background with better contrast options
    function calculateOptimalTextColor(backgroundColor) {
      const rgb = parseColorToRgb(backgroundColor);
      if (!rgb) return 'rgba(255, 255, 255, 0.9)'; // Default to light text
      
      const {r, g, b} = rgb;
      const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      
      // Return appropriate text color based on luminance
      if (yiq >= 128) {
        // Light background: use dark text with good opacity
        return 'rgba(0, 0, 0, 0.8)';
      } else {
        // Dark background: use light text with good opacity
        return 'rgba(255, 255, 255, 0.9)';
      }
    }

    // Enhanced function to detect parent document background color - works around cross-origin restrictions
    function getParentBackgroundColor() {
      console.log('Starting background color detection...');

      // Method 1: Visual background detection using canvas (works across origins!)
      var bgColor = detectVisualBackground();
      if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
        console.log('‚úÖ Visual background detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('‚ùå Visual background detection failed or returned transparent');
      }

      // Method 2: Enhanced URL-based detection with comprehensive database
      bgColor = detectComprehensiveSiteBackground();
      if (bgColor) {
        console.log('‚úÖ URL-based detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('‚ùå URL-based detection failed');
      }

      // Method 3: PostMessage communication with parent (if supported)
      bgColor = requestBackgroundFromParent();
      if (bgColor) {
        console.log('‚úÖ Parent communication successful:', bgColor);
        return bgColor;
      } else {
        console.log('‚ùå Parent communication failed or timed out');
      }

      // Method 4: Notion theme class detection
      bgColor = detectNotionThemeClasses();
      if (bgColor) {
        console.log('‚úÖ Notion theme class detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('‚ùå Notion theme class detection failed');
      }

      // Method 5: CSS custom properties (limited cross-origin support)
      bgColor = detectCSSCustomProperties();
      if (bgColor) {
        console.log('‚úÖ CSS custom properties detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('‚ùå CSS custom properties detection failed');
      }

      console.log('‚ùå All detection methods failed, returning null');
      return null;
    }

    // Enhanced visual background detection with Notion theme support
    function detectVisualBackground() {
      try {
        // Method 1: Create multiple test elements to detect different aspects
        var testDiv = document.createElement('div');
        testDiv.style.cssText = `
          position: fixed;
          top: 0; left: 0;
          width: 10px; height: 10px;
          z-index: -9999;
          visibility: hidden;
          pointer-events: none;
        `;

        document.body.appendChild(testDiv);

        // Get multiple computed properties
        var computedStyle = window.getComputedStyle(testDiv);
        var bgColor = computedStyle.backgroundColor;
        var themeClass = null;

        // Method 2: Try to detect Notion theme classes through computed styles
        try {
          // Check if we can detect theme-related CSS custom properties
          var rootStyles = window.getComputedStyle(document.documentElement);
          var notionBg = rootStyles.getPropertyValue('--notion-bg-color');
          var notionText = rootStyles.getPropertyValue('--notion-text-color');

          if (notionBg && notionBg !== '') {
            console.log('üé® Detected Notion CSS custom property:', notionBg);
            document.body.removeChild(testDiv);
            return notionBg;
          }
        } catch (e) {
          // CSS custom properties not available
        }

        // Method 3: Try to detect theme through body class inheritance
        var bodyClasses = '';
        try {
          // Create a more complex test to detect theme classes
          var bodyTest = document.createElement('body');
          var bodyComputed = window.getComputedStyle(document.body);
          bodyClasses = bodyComputed.fontFamily || ''; // Indirect way to detect changes

          // Check for theme indicators in computed styles
          if (bodyComputed.backgroundColor && bodyComputed.backgroundColor !== 'rgba(0, 0, 0, 0)') {
            bgColor = bodyComputed.backgroundColor;
          }
        } catch (e) {
          // Body access failed
        }

        document.body.removeChild(testDiv);

        // Method 4: Enhanced color validation
        if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
          // Additional validation for theme detection
          var rgb = parseColorToRgb(bgColor);
          if (rgb) {
            var yiq = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
            var isDark = yiq < 128;

            console.log('üé® Visual detection:', bgColor, '(Dark:', isDark + ')');
            return bgColor;
          }
        }

        return null;
      } catch (e) {
        console.log('‚ùå Visual detection failed:', e.message);
        return null;
      }
    }

    // Comprehensive site background database - expanded for better coverage
    function detectComprehensiveSiteBackground() {
      var referrer = document.referrer;
      console.log('Referrer URL:', referrer);

      if (!referrer) {
        console.log('No referrer available');
        return null;
      }

      try {
        var url = new URL(referrer);
        var hostname = url.hostname.toLowerCase();
        var pathname = url.pathname.toLowerCase();
        console.log('Parsed hostname:', hostname, 'pathname:', pathname);

        // Comprehensive database of sites and their typical background colors
        var siteDatabase = {
          // Note-taking & Documentation
          'notion.so': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(25, 25, 25)',
            patterns: {
              'desktop': 'rgb(255, 255, 255)',
              'mobile': 'rgb(255, 255, 255)'
            }
          },
          'notion.site': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(25, 25, 25)'
          },

          // Development & Code
          'github.com': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(13, 17, 23)',
            patterns: {
              'repositories': 'rgb(255, 255, 255)',
              'issues': 'rgb(255, 255, 255)',
              'pulls': 'rgb(255, 255, 255)'
            }
          },
          'gitlab.com': 'rgb(255, 255, 255)',
          'bitbucket.org': 'rgb(255, 255, 255)',
          'stackoverflow.com': 'rgb(255, 255, 255)',
          'stackexchange.com': 'rgb(255, 255, 255)',

          // Writing & Blogging
          'medium.com': 'rgb(255, 255, 255)',
          'dev.to': 'rgb(255, 255, 255)',
          'hashnode.dev': 'rgb(255, 255, 255)',
          'ghost.org': 'rgb(255, 255, 255)',

          // Social & Community
          'twitter.com': 'rgb(255, 255, 255)',
          'linkedin.com': 'rgb(255, 255, 255)',
          'reddit.com': 'rgb(255, 255, 255)',
          'discord.com': 'rgb(54, 57, 63)',

          // Productivity & Business
          'trello.com': 'rgb(240, 240, 240)',
          'asana.com': 'rgb(255, 255, 255)',
          'monday.com': 'rgb(255, 255, 255)',
          'clickup.com': 'rgb(255, 255, 255)',
          'airtable.com': 'rgb(255, 255, 255)',

          // Design & Creative
          'figma.com': 'rgb(255, 255, 255)',
          'dribbble.com': 'rgb(255, 255, 255)',
          'behance.net': 'rgb(255, 255, 255)',
          'canva.com': 'rgb(255, 255, 255)',

          // Learning & Education
          'coursera.org': 'rgb(255, 255, 255)',
          'udemy.com': 'rgb(255, 255, 255)',
          'edx.org': 'rgb(255, 255, 255)',
          'khanacademy.org': 'rgb(255, 255, 255)',

          // News & Media
          'nytimes.com': 'rgb(255, 255, 255)',
          'theguardian.com': 'rgb(255, 255, 255)',
          'bbc.com': 'rgb(255, 255, 255)',
          'cnn.com': 'rgb(255, 255, 255)',

          // E-commerce
          'amazon.com': 'rgb(255, 255, 255)',
          'ebay.com': 'rgb(255, 255, 255)',
          'shopify.com': 'rgb(255, 255, 255)',

          // Cloud & Services
          'aws.amazon.com': 'rgb(255, 255, 255)',
          'azure.microsoft.com': 'rgb(255, 255, 255)',
          'cloud.google.com': 'rgb(255, 255, 255)',
          'digitalocean.com': 'rgb(255, 255, 255)',
          'vercel.com': 'rgb(255, 255, 255)',
          'netlify.com': 'rgb(255, 255, 255)',

          // Analytics & Marketing
          'google.com/analytics': 'rgb(255, 255, 255)',
          'mixpanel.com': 'rgb(255, 255, 255)',
          'segment.com': 'rgb(255, 255, 255)',
          'hubspot.com': 'rgb(255, 255, 255)',

          // Communication
          'slack.com': 'rgb(248, 249, 250)',
          'teams.microsoft.com': 'rgb(255, 255, 255)',
          'zoom.us': 'rgb(255, 255, 255)',
          'meet.google.com': 'rgb(255, 255, 255)',

          // File Storage
          'drive.google.com': 'rgb(255, 255, 255)',
          'dropbox.com': 'rgb(255, 255, 255)',
          'onedrive.live.com': 'rgb(255, 255, 255)',
          'box.com': 'rgb(255, 255, 255)',

          // Development Tools
          'codepen.io': 'rgb(255, 255, 255)',
          'jsfiddle.net': 'rgb(255, 255, 255)',
          'repl.it': 'rgb(255, 255, 255)',
          'codesandbox.io': 'rgb(255, 255, 255)',
          'glitch.com': 'rgb(255, 255, 255)',

          // Video & Streaming
          'youtube.com': 'rgb(255, 255, 255)',
          'vimeo.com': 'rgb(255, 255, 255)',
          'twitch.tv': 'rgb(15, 15, 15)',

          // Music & Audio
          'spotify.com': 'rgb(25, 20, 20)',
          'soundcloud.com': 'rgb(255, 85, 46)',
          'bandcamp.com': 'rgb(255, 255, 255)',

          // Health & Fitness
          'strava.com': 'rgb(255, 255, 255)',
          'myfitnesspal.com': 'rgb(255, 255, 255)',
          'fitbit.com': 'rgb(255, 255, 255)',

          // Finance
          'mint.com': 'rgb(255, 255, 255)',
          'personalcapital.com': 'rgb(255, 255, 255)',
          'ynab.com': 'rgb(255, 255, 255)',

          // Travel
          'airbnb.com': 'rgb(255, 255, 255)',
          'booking.com': 'rgb(255, 255, 255)',
          'expedia.com': 'rgb(255, 255, 255)',
          'kayak.com': 'rgb(255, 255, 255)',

          // Food & Cooking
          'allrecipes.com': 'rgb(255, 255, 255)',
          'foodnetwork.com': 'rgb(255, 255, 255)',
          'epicurious.com': 'rgb(255, 255, 255)',

          // Gaming
          'steam.com': 'rgb(23, 26, 33)',
          'epicgames.com': 'rgb(255, 255, 255)',
          'gog.com': 'rgb(255, 255, 255)',
          'itch.io': 'rgb(255, 255, 255)',

          // Science & Research
          'wikipedia.org': 'rgb(255, 255, 255)',
          'researchgate.net': 'rgb(255, 255, 255)',
          'academia.edu': 'rgb(255, 255, 255)',
          'arxiv.org': 'rgb(255, 255, 255)',

          // Government & Legal
          'usa.gov': 'rgb(255, 255, 255)',
          'gov.uk': 'rgb(255, 255, 255)',
          'whitehouse.gov': 'rgb(255, 255, 255)',

          // Dark theme sites
          'biznuts.github.io': 'rgb(25, 25, 25)', // Your specific case
          'github.io': 'rgb(25, 25, 25)', // GitHub Pages dark themes
        };

        // Check for exact hostname match first
        if (siteDatabase[hostname]) {
          var siteInfo = siteDatabase[hostname];

          // If it's an object with multiple options, choose based on context
          if (typeof siteInfo === 'object' && siteInfo.default) {
            // Check for dark theme indicators in URL
            if (pathname.includes('dark') || pathname.includes('night') ||
                document.cookie.includes('dark') || document.cookie.includes('theme=dark')) {
              return siteInfo.dark || siteInfo.default;
            }

            // Check for specific patterns
            if (siteInfo.patterns) {
              for (var pattern in siteInfo.patterns) {
                if (pathname.includes(pattern)) {
                  return siteInfo.patterns[pattern];
                }
              }
            }

            return siteInfo.default;
          }

          return siteInfo;
        }

        // Special case for biznuts.github.io - prioritize this match
        if (hostname === 'biznuts.github.io') {
          console.log('üéØ Detected biznuts.github.io, using dark theme background');
          return 'rgb(25, 25, 25)';
        }

        // Check for partial matches (e.g., subdomains)
        for (var site in siteDatabase) {
          if (hostname.includes(site) || site.includes(hostname)) {
            var siteInfo = siteDatabase[site];
            if (typeof siteInfo === 'object' && siteInfo.default) {
              return siteInfo.default;
            }
            return siteInfo;
          }
        }

        return null;
      } catch (e) {
        console.log('Error in comprehensive site detection:', e.message);
        return null;
      }
    }

    // PostMessage communication with parent window for background color
    function requestBackgroundFromParent() {
      try {
        // Send a request to parent window for background information
        var requestId = 'bg_request_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var request = {
          type: 'GET_BACKGROUND_COLOR',
          id: requestId,
          source: 'feedback_widget'
        };

        window.parent.postMessage(request, '*');

        // Set up a one-time listener for the response
        return new Promise(function(resolve) {
          var timeout = setTimeout(function() {
            window.removeEventListener('message', responseHandler);
            resolve(null);
          }, 1000); // 1 second timeout

          function responseHandler(event) {
            if (event.data && event.data.type === 'BACKGROUND_COLOR_RESPONSE' &&
                event.data.id === requestId) {
              clearTimeout(timeout);
              window.removeEventListener('message', responseHandler);
              resolve(event.data.backgroundColor);
            }
          }

          window.addEventListener('message', responseHandler);
        });
      } catch (e) {
        console.log('PostMessage communication failed:', e.message);
        return null;
      }
    }

    // Enhanced CSS custom properties detection with Notion theme support
    function detectCSSCustomProperties() {
      try {
        // Try to read CSS custom properties that might be inherited
        var rootStyles = window.getComputedStyle(document.documentElement);

        // Comprehensive list of CSS custom properties for themes
        var bgProperties = [
          // Standard theme properties
          '--bg-color', '--background-color', '--bg-primary',
          '--color-background', '--surface-background',
          '--theme-bg-color', '--theme-background',

          // Notion-specific properties
          '--notion-bg-color', '--notion-background-color',
          '--notion-text-color', '--notion-theme-bg', '--notion-theme-text',
          '--notion-auto-text-color',

          // Common theme system properties
          '--color-bg', '--color-surface', '--surface-bg',
          '--primary-bg', '--secondary-bg',

          // Dark/Light theme indicators
          '--is-dark', '--theme-mode', '--color-scheme'
        ];

        for (var i = 0; i < bgProperties.length; i++) {
          var propValue = rootStyles.getPropertyValue(bgProperties[i]);
          if (propValue && propValue !== '') {
            console.log('üé® Found CSS custom property:', bgProperties[i], '=', propValue);

            // Special handling for Notion theme properties
            if (bgProperties[i].includes('notion') && bgProperties[i].includes('bg')) {
              console.log('üéØ Notion background property detected:', propValue);
              return propValue;
            }

            // Check for theme mode indicators
            if (bgProperties[i].includes('theme-mode') || bgProperties[i].includes('is-dark')) {
              if (propValue.includes('dark')) {
                console.log('üåô Dark theme detected via CSS property');
                return 'rgb(25, 25, 25)'; // Notion dark background
              }
            }

            return propValue;
          }
        }

        return null;
      } catch (e) {
        console.log('CSS custom properties detection failed:', e.message);
        return null;
      }
    }

    // Specific function to detect Notion theme classes and indicators
    function detectNotionThemeClasses() {
      try {
        console.log('üîç Detecting Notion theme classes...');

        // Check document body for theme-related classes
        var bodyClasses = document.body.className || '';
        console.log('Body classes:', bodyClasses);

        // Check for Notion theme indicators in body classes
        if (bodyClasses.includes('dark') || bodyClasses.includes('notion-dark')) {
          console.log('üåô Notion dark theme detected via body classes');
          return 'rgb(25, 25, 25)';
        }

        if (bodyClasses.includes('light') || bodyClasses.includes('notion-light')) {
          console.log('‚òÄÔ∏è Notion light theme detected via body classes');
          return 'rgb(255, 255, 255)';
        }

        // Check HTML element for theme classes
        var htmlClasses = document.documentElement.className || '';
        console.log('HTML classes:', htmlClasses);

        if (htmlClasses.includes('dark') || htmlClasses.includes('notion-dark-theme')) {
          console.log('üåô Notion dark theme detected via HTML classes');
          return 'rgb(25, 25, 25)';
        }

        if (htmlClasses.includes('light') || htmlClasses.includes('notion-light-theme')) {
          console.log('‚òÄÔ∏è Notion light theme detected via HTML classes');
          return 'rgb(255, 255, 255)';
        }

        // Check for data attributes that might indicate theme
        var bodyDataTheme = document.body.getAttribute('data-theme') ||
                           document.documentElement.getAttribute('data-theme');

        if (bodyDataTheme) {
          console.log('Data theme attribute:', bodyDataTheme);
          if (bodyDataTheme.includes('dark')) {
            return 'rgb(25, 25, 25)';
          } else if (bodyDataTheme.includes('light')) {
            return 'rgb(255, 255, 255)';
          }
        }

        return null;
      } catch (e) {
        console.log('Notion theme class detection failed:', e.message);
        return null;
      }
    }

    // Enhanced function to detect Notion theme colors (legacy compatibility)
    function detectNotionTheme() {
      var theme = {
        background: null,
        text: null,
        isDark: false
      };

      // Use the enhanced parent detection
      theme.background = getParentBackgroundColor();

      if (theme.background && theme.background !== 'transparent' && theme.background !== 'rgba(0, 0, 0, 0)') {
        var rgb = parseColorToRgb(theme.background);
        if (rgb) {
          var yiq = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
          theme.isDark = yiq < 128;
          theme.text = calculateOptimalTextColor(theme.background);
        }
      }

      return theme;
    }

    // Enhanced function to apply auto-contrast with improved color detection
    function applyAutoContrast() {
      var elements = document.querySelectorAll('.auto-contrast-text');
      var notionTheme = detectNotionTheme();

      elements.forEach(function (element) {
        var finalColor = null;

        // Priority 1: Use parent document background if available (for embedded widgets)
        if (element.classList.contains('notion-enhanced') && notionTheme.background) {
          finalColor = calculateOptimalTextColor(notionTheme.background);
          console.log('Using parent background - Background:', notionTheme.background, 'Text color:', finalColor);
        }

        // Priority 2: Use local background detection if no parent color available
        if (!finalColor) {
          var bgColor = findElementBackgroundColor(element);

          if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
            finalColor = calculateOptimalTextColor(bgColor);
            console.log('Using local background - Background:', bgColor, 'Text color:', finalColor);
          } else {
            // Priority 3: Use CSS custom properties if available
            finalColor = useCSSCustomProperties(element);
          }
        }

        // Priority 4: Final fallback - use a sensible default based on element class
        if (!finalColor) {
          finalColor = element.classList.contains('notion-enhanced') ?
            'rgba(255, 255, 255, 0.9)' : // Default for Notion themes
            'rgba(0, 0, 0, 0.8)';        // Default for other themes
          console.log('Using fallback color for element:', element.className, 'Color:', finalColor);
        }

        // Apply the determined color with high specificity
        if (finalColor) {
          element.style.setProperty('color', finalColor, 'important');
        }
      });
    }

    // Helper function to find the effective background color of an element
    function findElementBackgroundColor(element) {
      // Get the background color of the element itself
      var elementBgColor = window.getComputedStyle(element).backgroundColor;

      // If element has no background, check parent elements
      var bgColor = elementBgColor;
      if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent') {
        var parent = element.parentElement;
        var maxDepth = 10; // Prevent infinite loops
        var depth = 0;

        while (parent && depth < maxDepth && (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent')) {
          bgColor = window.getComputedStyle(parent).backgroundColor;
          parent = parent.parentElement;
          depth++;
        }
      }

      return bgColor;
    }

    // Helper function to use CSS custom properties if available
    function useCSSCustomProperties(element) {
      try {
        var computedStyle = window.getComputedStyle(element);
        var bgColor = computedStyle.backgroundColor;

        if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
          return calculateOptimalTextColor(bgColor);
        }

        // Check for CSS custom properties
        var customBg = computedStyle.getPropertyValue('--bg-color');
        if (customBg) {
          return calculateOptimalTextColor(customBg);
        }
      } catch (e) {
        console.log('Error accessing computed styles:', e.message);
      }

      return null;
    }

    // Enhanced PostMessage listener for theme changes
    window.addEventListener('message', function(event) {
      // Verify origin for security (allow Notion domains and parent origin)
      var isAllowedOrigin = event.origin.includes('notion.so') ||
                           event.origin.includes('notion.site') ||
                           event.origin === window.location.origin;

      if (isAllowedOrigin) {
        // Handle theme change notifications
        if (event.data && event.data.type === 'themeChange') {
          console.log('üé® Theme change detected:', event.data);
          clearColorCache();
          setTimeout(applyAutoContrast, 100);
        }

        // Handle background color responses
        if (event.data && event.data.type === 'BACKGROUND_COLOR_RESPONSE') {
          console.log('üé® Background color response received:', event.data.backgroundColor);
          if (event.data.backgroundColor) {
            clearColorCache();
            // Update color immediately if we receive a response
            var testElement = document.querySelector('.auto-contrast-text');
            if (testElement) {
              var optimalColor = calculateOptimalTextColor(event.data.backgroundColor);
              testElement.style.setProperty('color', optimalColor, 'important');
            }
          }
        }

        // Handle Notion-specific theme indicators
        if (event.data && event.data.type === 'NOTION_THEME_UPDATE') {
          console.log('üéØ Notion theme update:', event.data.theme);
          clearColorCache();

          var notionBgColor = 'rgb(255, 255, 255)'; // default light
          if (event.data.theme === 'dark' || event.data.theme === 'notion-dark') {
            notionBgColor = 'rgb(25, 25, 25)';
          }

          // Force update for all Notion-enhanced elements
          var notionElements = document.querySelectorAll('.notion-enhanced');
          notionElements.forEach(function(element) {
            var optimalColor = calculateOptimalTextColor(notionBgColor);
            element.style.setProperty('color', optimalColor, 'important');
          });
        }
      }
    });

    // Apply auto-contrast when page loads
    document.addEventListener('DOMContentLoaded', function () {
      applyAutoContrast();
      setupEnhancedObserver(); // Use the enhanced observer instead
    });

    // Apply auto-contrast when Lyket widget loads (in case it changes colors)
    document.addEventListener('DOMNodeInserted', function () {
      setTimeout(applyAutoContrast, 100);
    });

    // Performance optimization: Cache computed values to avoid redundant calculations
    var colorCache = new Map();
    var lastParentBg = null;

    function getCachedOptimalColor(backgroundColor) {
      if (colorCache.has(backgroundColor)) {
        return colorCache.get(backgroundColor);
      }

      var optimalColor = calculateOptimalTextColor(backgroundColor);
      colorCache.set(backgroundColor, optimalColor);
      return optimalColor;
    }

    // Enhanced observer setup - works around cross-origin restrictions
    function setupEnhancedObserver() {
      try {
        // Method 1: Monitor our own document for style changes that might indicate parent changes
        var localObserver = new MutationObserver(function(mutations) {
          var shouldUpdate = false;

          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              shouldUpdate = true;
            }
            if (mutation.type === 'childList') {
              // Check if background-related elements were added/removed
              var hasBgElements = Array.from(mutation.addedNodes).some(function(node) {
                return node.nodeType === Node.ELEMENT_NODE &&
                       (node.style && node.style.backgroundColor) ||
                       node.classList && node.classList.contains('has-background');
              });
              if (hasBgElements) shouldUpdate = true;
            }
          });

          if (shouldUpdate) {
            console.log('Local style change detected, updating colors...');
            clearColorCache();
            setTimeout(applyAutoContrast, 100);
          }
        });

        localObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['style'],
          childList: true,
          subtree: true
        });

        // Method 2: Intelligent polling for theme changes (ultra-responsive for Notion)
        var lastVisualBg = null;
        var lastNotionCheck = 0;
        var pollInterval = setInterval(function() {
          try {
            var currentTime = Date.now();
            var notionDetected = document.referrer && document.referrer.includes('notion');

            // Ultra-frequent polling for Notion (every 800ms for first 10 seconds)
            if (notionDetected && (currentTime - lastNotionCheck) > 800) {
              lastNotionCheck = currentTime;

              // Check visual background
              var currentVisualBg = detectVisualBackground();
              if (currentVisualBg && currentVisualBg !== lastVisualBg) {
                console.log('üé® Notion background change detected:', currentVisualBg);
                lastVisualBg = currentVisualBg;
                clearColorCache();
                applyAutoContrast();
              }

              // Also check for theme class changes
              var themeBg = detectNotionThemeClasses();
              if (themeBg && themeBg !== lastVisualBg) {
                console.log('üéØ Notion theme class change detected:', themeBg);
                lastVisualBg = themeBg;
                clearColorCache();
                applyAutoContrast();
              }
            }
            // Regular polling for non-Notion sites (every 3 seconds)
            else if (!notionDetected && (currentTime % 3000) < 100) {
              var currentVisualBg = detectVisualBackground();
              if (currentVisualBg && currentVisualBg !== lastVisualBg) {
                console.log('üé® Background change detected:', currentVisualBg);
                lastVisualBg = currentVisualBg;
                clearColorCache();
                applyAutoContrast();
              }
            }
          } catch (e) {
            console.log('Polling error (non-critical):', e.message);
          }
        }, 800); // Very frequent polling (800ms) for maximum responsiveness

        // Method 3: Listen for postMessage theme change notifications
        window.addEventListener('message', function(event) {
          if (event.data && event.data.type === 'themeChange') {
            console.log('Theme change notification received:', event.data);
            clearColorCache();
            setTimeout(applyAutoContrast, 100);
          }
        });

        console.log('Enhanced observer setup complete (cross-origin compatible)');
      } catch (e) {
        console.log('Could not set up enhanced observer:', e.message);
      }
    }

    function clearColorCache() {
      colorCache.clear();
      lastParentBg = null;
    }

    // Make enhanced functions globally available for testing and debugging
    window.testAutoContrast = applyAutoContrast;
    window.detectNotionTheme = detectNotionTheme;
    window.getParentBackgroundColor = getParentBackgroundColor;
    window.calculateOptimalTextColor = calculateOptimalTextColor;
    window.clearColorCache = clearColorCache;
    window.detectNotionThemeClasses = detectNotionThemeClasses;
    window.detectVisualBackground = detectVisualBackground;

    // Manual theme update function for testing
    window.forceThemeUpdate = function(theme) {
      console.log('üîß Forcing theme update to:', theme);
      clearColorCache();

      var themeColors = {
        'light': 'rgb(255, 255, 255)',
        'dark': 'rgb(25, 25, 25)',
        'notion-light': 'rgb(255, 255, 255)',
        'notion-dark': 'rgb(25, 25, 25)',
        'auto': null // Auto-detect
      };

      var bgColor = themeColors[theme] || (theme === 'auto' ? null : theme);

      if (bgColor) {
        var elements = document.querySelectorAll('.auto-contrast-text');
        elements.forEach(function(element) {
          var optimalColor = calculateOptimalTextColor(bgColor);
          element.style.setProperty('color', optimalColor, 'important');
          console.log('‚úÖ Applied color:', optimalColor, 'for background:', bgColor);
        });
      } else {
        // Auto-detect
        applyAutoContrast();
      }
    };

    // Enhanced debugging function
    window.debugColorDetection = function() {
      console.log('=== Color Detection Debug Info ===');
      console.log('Parent background:', getParentBackgroundColor());
      console.log('Notion theme:', detectNotionTheme());
      console.log('Notion theme classes:', detectNotionThemeClasses());
      console.log('Visual background:', detectVisualBackground());
      console.log('Cache size:', colorCache.size);
      console.log('Referrer:', document.referrer);
      console.log('Available functions:', Object.keys(window).filter(k => k.includes('Color') || k.includes('Theme')));
    };
  </script>
</body>

</html>
