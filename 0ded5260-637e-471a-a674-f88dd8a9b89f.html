<!DOCTYPE html>
<html>

<head>
  <style>
    /* Global white color override for non-auto-contrast elements */
    *:not(.auto-contrast-text) {
      color: white !important;
    }

    html {
      height: 100%;
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, 'Segoe UI Variable Display', 'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji', 'Segoe UI Symbol';
    }

    body {
      /* background-color: rgb(25, 25, 25); */
      background-color: transparent;
      margin: 0;
      padding: 0px;
    }

    .feedback-widget {
      display: inline-flex;
      align-items: center;
      padding: 0px 12px 0px 0px;
    }

    /* Ensure auto-contrast text color overrides take precedence */
    .auto-contrast-text,
    .auto-contrast-text * {
      color: inherit !important;
      font-weight: 500;
    }

    /* Notion theme support - try to inherit theme colors if available */
    .notion-theme-aware {
      background-color: var(--notion-bg-color, var(--notion-theme-bg, inherit));
      color: var(--notion-text-color, var(--notion-theme-text, inherit));
    }

    /* Enhanced auto-contrast with Notion theme fallbacks */
    .auto-contrast-text.notion-enhanced {
      /* Use Notion theme colors if available, fallback to auto-calculation */
      color: var(--notion-auto-text-color, inherit);
    }
  </style>
</head>

<body class="page-body ">
  <div class="feedback-widget auto-contrast-text notion-enhanced">
    <span>Just let me know if you think this is helpful.</span>
    <span data-lyket-type="like" data-lyket-id="0ded5260-637e-471a-a674-f88dd8a9b89f" data-lyket-namespace="notion"
      data-lyket-template="twitter"></span>
  </div>
  <script src="https://unpkg.com/@lyket/widget@latest/dist/lyket.js?apiKey=pt_c791403c654b27c63cd0926a8d1f37"></script>

  <script>
    // Enhanced function to parse any CSS color format to RGB
    function parseColorToRgb(color) {
      if (!color || color === 'transparent' || color === 'rgba(0, 0, 0, 0)') return null;
      
      // Create a temporary element to get computed style
      var tempDiv = document.createElement('div');
      tempDiv.style.color = color;
      tempDiv.style.display = 'none';
      document.body.appendChild(tempDiv);
      var computedColor = window.getComputedStyle(tempDiv).color;
      document.body.removeChild(tempDiv);

      // Parse RGB values - handle both rgb() and rgba() formats
      var rgbMatch = computedColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      
      // Handle hex colors, named colors, etc. that computed style returns as rgb
      if (computedColor.startsWith('rgb')) {
        rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          return {
            r: parseInt(rgbMatch[1]),
            g: parseInt(rgbMatch[2]),
            b: parseInt(rgbMatch[3])
          };
        }
      }
      
      return null;
    }

    // Enhanced function to calculate if a color is light or dark with better algorithm
    function getContrastYIQ(r, g, b) {
      // YIQ formula for luminance (more accurate than simple average)
      var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      return (yiq >= 128) ? 'light' : 'dark';
    }

    // Calculate optimal text color based on background with better contrast options
    function calculateOptimalTextColor(backgroundColor) {
      const rgb = parseColorToRgb(backgroundColor);
      if (!rgb) return 'rgba(255, 255, 255, 0.9)'; // Default to light text
      
      const {r, g, b} = rgb;
      const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      
      // Return appropriate text color based on luminance
      if (yiq >= 128) {
        // Light background: use dark text with good opacity
        return 'rgba(0, 0, 0, 0.8)';
      } else {
        // Dark background: use light text with good opacity
        return 'rgba(255, 255, 255, 0.9)';
      }
    }

    // Enhanced function to detect parent document background color with better iframe support
    function getParentBackgroundColor() {
      var bgColor = null;

      // Method 1: Try direct parent access (works in same-origin iframes)
      try {
        if (window.parent && window.parent.document) {
          var parentBody = window.parent.document.body;
          if (parentBody) {
            var parentStyles = window.parent.getComputedStyle(parentBody);
            if (parentStyles && parentStyles.backgroundColor) {
              bgColor = parentStyles.backgroundColor;
              console.log('Successfully detected parent background:', bgColor);
            }
          }
        }
      } catch (e) {
        console.log('Cross-origin iframe restriction (Method 1):', e.message);
      }

      // Method 2: Try to access through referrer or URL patterns (fallback)
      if (!bgColor || bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {
        bgColor = detectKnownSiteBackground(document.referrer);
      }

      // Method 3: Try to detect from CSS custom properties if parent supports them
      if (!bgColor || bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {
        try {
          if (window.parent && window.parent.document) {
            var parentRoot = window.parent.document.documentElement;
            var parentStyles = window.parent.getComputedStyle(parentRoot);
            if (parentStyles && parentStyles.getPropertyValue('--bg-color')) {
              bgColor = parentStyles.getPropertyValue('--bg-color');
              console.log('Detected CSS custom property background:', bgColor);
            }
          }
        } catch (e) {
          console.log('Could not access parent CSS properties:', e.message);
        }
      }

      return bgColor;
    }

    // Helper function to detect background colors of known sites
    function detectKnownSiteBackground(referrer) {
      if (!referrer) return null;

      try {
        var url = new URL(referrer);
        var hostname = url.hostname.toLowerCase();

        // Known site background colors (you can expand this database)
        var knownSites = {
          'notion.so': 'rgb(255, 255, 255)', // Default Notion light theme
          'notion.site': 'rgb(255, 255, 255)',
          'github.com': 'rgb(255, 255, 255)',
          'stackoverflow.com': 'rgb(255, 255, 255)',
          'medium.com': 'rgb(255, 255, 255)',
          'dev.to': 'rgb(255, 255, 255)'
        };

        return knownSites[hostname] || null;
      } catch (e) {
        console.log('Error parsing referrer URL:', e.message);
        return null;
      }
    }

    // Enhanced function to detect Notion theme colors (legacy compatibility)
    function detectNotionTheme() {
      var theme = {
        background: null,
        text: null,
        isDark: false
      };

      // Use the enhanced parent detection
      theme.background = getParentBackgroundColor();

      if (theme.background && theme.background !== 'transparent' && theme.background !== 'rgba(0, 0, 0, 0)') {
        var rgb = parseColorToRgb(theme.background);
        if (rgb) {
          var yiq = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
          theme.isDark = yiq < 128;
          theme.text = calculateOptimalTextColor(theme.background);
        }
      }

      return theme;
    }

    // Enhanced function to apply auto-contrast with improved color detection
    function applyAutoContrast() {
      var elements = document.querySelectorAll('.auto-contrast-text');
      var notionTheme = detectNotionTheme();

      elements.forEach(function (element) {
        var finalColor = null;

        // Priority 1: Use parent document background if available (for embedded widgets)
        if (element.classList.contains('notion-enhanced') && notionTheme.background) {
          finalColor = calculateOptimalTextColor(notionTheme.background);
          console.log('Using parent background - Background:', notionTheme.background, 'Text color:', finalColor);
        }

        // Priority 2: Use local background detection if no parent color available
        if (!finalColor) {
          var bgColor = findElementBackgroundColor(element);

          if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
            finalColor = calculateOptimalTextColor(bgColor);
            console.log('Using local background - Background:', bgColor, 'Text color:', finalColor);
          } else {
            // Priority 3: Use CSS custom properties if available
            finalColor = useCSSCustomProperties(element);
          }
        }

        // Priority 4: Final fallback - use a sensible default based on element class
        if (!finalColor) {
          finalColor = element.classList.contains('notion-enhanced') ?
            'rgba(255, 255, 255, 0.9)' : // Default for Notion themes
            'rgba(0, 0, 0, 0.8)';        // Default for other themes
          console.log('Using fallback color for element:', element.className, 'Color:', finalColor);
        }

        // Apply the determined color with high specificity
        if (finalColor) {
          element.style.setProperty('color', finalColor, 'important');
        }
      });
    }

    // Helper function to find the effective background color of an element
    function findElementBackgroundColor(element) {
      // Get the background color of the element itself
      var elementBgColor = window.getComputedStyle(element).backgroundColor;

      // If element has no background, check parent elements
      var bgColor = elementBgColor;
      if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent') {
        var parent = element.parentElement;
        var maxDepth = 10; // Prevent infinite loops
        var depth = 0;

        while (parent && depth < maxDepth && (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent')) {
          bgColor = window.getComputedStyle(parent).backgroundColor;
          parent = parent.parentElement;
          depth++;
        }
      }

      return bgColor;
    }

    // Helper function to use CSS custom properties if available
    function useCSSCustomProperties(element) {
      try {
        var computedStyle = window.getComputedStyle(element);
        var bgColor = computedStyle.backgroundColor;

        if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
          return calculateOptimalTextColor(bgColor);
        }

        // Check for CSS custom properties
        var customBg = computedStyle.getPropertyValue('--bg-color');
        if (customBg) {
          return calculateOptimalTextColor(customBg);
        }
      } catch (e) {
        console.log('Error accessing computed styles:', e.message);
      }

      return null;
    }

    // Listen for Notion theme changes via PostMessage API
    window.addEventListener('message', function(event) {
      // Verify origin for security (adjust as needed for Notion domains)
      if (event.origin.includes('notion.so') || event.origin.includes('notion.site')) {
        if (event.data && event.data.type === 'themeChange') {
          console.log('Notion theme change detected:', event.data);
          setTimeout(applyAutoContrast, 100);
        }
      }
    });

    // Apply auto-contrast when page loads
    document.addEventListener('DOMContentLoaded', function () {
      applyAutoContrast();
      setupEnhancedObserver(); // Use the enhanced observer instead
    });

    // Apply auto-contrast when Lyket widget loads (in case it changes colors)
    document.addEventListener('DOMNodeInserted', function () {
      setTimeout(applyAutoContrast, 100);
    });

    // Performance optimization: Cache computed values to avoid redundant calculations
    var colorCache = new Map();
    var lastParentBg = null;

    function getCachedOptimalColor(backgroundColor) {
      if (colorCache.has(backgroundColor)) {
        return colorCache.get(backgroundColor);
      }

      var optimalColor = calculateOptimalTextColor(backgroundColor);
      colorCache.set(backgroundColor, optimalColor);
      return optimalColor;
    }

    // Enhanced observer setup with better performance
    function setupEnhancedObserver() {
      try {
        if (window.parent && window.parent.document) {
          var observer = new MutationObserver(function(mutations) {
            var styleChanged = false;

            mutations.forEach(function(mutation) {
              if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                styleChanged = true;
              }
              if (mutation.type === 'childList') {
                // Check if background-related elements were added/removed
                var hasBgElements = Array.from(mutation.addedNodes).some(function(node) {
                  return node.nodeType === Node.ELEMENT_NODE &&
                         (node.style && node.style.backgroundColor) ||
                         node.classList && node.classList.contains('has-background');
                });
                if (hasBgElements) styleChanged = true;
              }
            });

            if (styleChanged) {
              console.log('Parent style change detected, updating colors...');
              clearColorCache(); // Clear cache when styles change
              setTimeout(applyAutoContrast, 50); // Small delay for style computation
            }
          });

          observer.observe(window.parent.document.body, {
            attributes: true,
            attributeFilter: ['style'],
            childList: true,
            subtree: true
          });

          console.log('Enhanced observer setup complete');
        }
      } catch (e) {
        console.log('Could not set up enhanced observer (iframe restriction):', e.message);
      }
    }

    function clearColorCache() {
      colorCache.clear();
      lastParentBg = null;
    }

    // Make enhanced functions globally available for testing and debugging
    window.testAutoContrast = applyAutoContrast;
    window.detectNotionTheme = detectNotionTheme;
    window.getParentBackgroundColor = getParentBackgroundColor;
    window.calculateOptimalTextColor = calculateOptimalTextColor;
    window.clearColorCache = clearColorCache;

    // Enhanced debugging function
    window.debugColorDetection = function() {
      console.log('=== Color Detection Debug Info ===');
      console.log('Parent background:', getParentBackgroundColor());
      console.log('Notion theme:', detectNotionTheme());
      console.log('Cache size:', colorCache.size);
      console.log('Available functions:', Object.keys(window).filter(k => k.includes('Color')));
    };
  </script>
</body>

</html>
