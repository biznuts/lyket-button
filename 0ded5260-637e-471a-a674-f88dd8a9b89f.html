<!DOCTYPE html>
<html>

<head>
  <style>
    /* Global black color override for non-auto-contrast elements */
    *:not(.auto-contrast-text) {
      color: rgb(0, 0, 0) !important;
    }

    html {
      height: 100%;
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, 'Segoe UI Variable Display', 'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji', 'Segoe UI Symbol';
    }

    body {
      /* background-color: rgb(25, 25, 25); */
      background-color: transparent;
      margin: 0;
      padding: 0px;
    }

    .feedback-widget {
      display: inline-flex;
      align-items: center;
      padding: 0px 12px 0px 0px;
    }

    /* Ensure auto-contrast text color overrides take precedence */
    .auto-contrast-text,
    .auto-contrast-text * {
      color: inherit !important;
      font-weight: 500;
    }

    /* Notion theme support - try to inherit theme colors if available */
    .notion-theme-aware {
      background-color: var(--notion-bg-color, var(--notion-theme-bg, inherit));
      color: var(--notion-text-color, var(--notion-theme-text, inherit));
    }

    /* Enhanced auto-contrast with Notion theme fallbacks */
    .auto-contrast-text.notion-enhanced {
      /* Use Notion theme colors if available, fallback to auto-calculation */
      color: var(--notion-auto-text-color, inherit);
    }
  </style>
</head>

<body class="page-body ">
  <div class="feedback-widget auto-contrast-text notion-enhanced">
    <span>Just let me know if you think this is helpful.</span>
    <span data-lyket-type="like" data-lyket-id="0ded5260-637e-471a-a674-f88dd8a9b89f" data-lyket-namespace="notion"
      data-lyket-template="twitter"></span>
  </div>
  <script src="https://unpkg.com/@lyket/widget@latest/dist/lyket.js?apiKey=pt_c791403c654b27c63cd0926a8d1f37"></script>

  <script>
    // Enhanced function to parse any CSS color format to RGB
    function parseColorToRgb(color) {
      if (!color || color === 'transparent' || color === 'rgba(0, 0, 0, 0)') return null;
      
      // Create a temporary element to get computed style
      var tempDiv = document.createElement('div');
      tempDiv.style.color = color;
      tempDiv.style.display = 'none';
      document.body.appendChild(tempDiv);
      var computedColor = window.getComputedStyle(tempDiv).color;
      document.body.removeChild(tempDiv);

      // Parse RGB values - handle both rgb() and rgba() formats
      var rgbMatch = computedColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      
      // Handle hex colors, named colors, etc. that computed style returns as rgb
      if (computedColor.startsWith('rgb')) {
        rgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          return {
            r: parseInt(rgbMatch[1]),
            g: parseInt(rgbMatch[2]),
            b: parseInt(rgbMatch[3])
          };
        }
      }
      
      return null;
    }

    // Enhanced function to calculate if a color is light or dark with better algorithm
    function getContrastYIQ(r, g, b) {
      // YIQ formula for luminance (more accurate than simple average)
      var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      return (yiq >= 128) ? 'light' : 'dark';
    }

    // Calculate optimal text color based on background with better contrast options
    function calculateOptimalTextColor(backgroundColor) {
      const rgb = parseColorToRgb(backgroundColor);
      if (!rgb) return 'rgba(255, 255, 255, 0.9)'; // Default to light text
      
      const {r, g, b} = rgb;
      const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      
      // Return appropriate text color based on luminance
      if (yiq >= 128) {
        // Light background: use dark text with good opacity
        return 'rgba(0, 0, 0, 0.8)';
      } else {
        // Dark background: use light text with good opacity
        return 'rgba(255, 255, 255, 0.9)';
      }
    }

    // Enhanced function to detect parent document background color - works around cross-origin restrictions
    function getParentBackgroundColor() {
      console.log('Starting background color detection...');

      // Method 1: Visual background detection using canvas (works across origins!)
      var bgColor = detectVisualBackground();
      if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
        console.log('✅ Visual background detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('❌ Visual background detection failed or returned transparent');
      }

      // Method 2: Enhanced URL-based detection with comprehensive database
      bgColor = detectComprehensiveSiteBackground();
      if (bgColor) {
        console.log('✅ URL-based detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('❌ URL-based detection failed');
      }

      // Method 3: PostMessage communication with parent (if supported)
      bgColor = requestBackgroundFromParent();
      if (bgColor) {
        console.log('✅ Parent communication successful:', bgColor);
        return bgColor;
      } else {
        console.log('❌ Parent communication failed or timed out');
      }

      // Method 4: CSS custom properties (limited cross-origin support)
      bgColor = detectCSSCustomProperties();
      if (bgColor) {
        console.log('✅ CSS custom properties detection successful:', bgColor);
        return bgColor;
      } else {
        console.log('❌ CSS custom properties detection failed');
      }

      console.log('❌ All detection methods failed, returning null');
      return null;
    }

    // Cross-browser visual background detection - works across origins!
    function detectVisualBackground() {
      try {
        // Method 1: Try to create a temporary element that inherits parent background
        var testDiv = document.createElement('div');
        testDiv.style.position = 'fixed';
        testDiv.style.top = '0';
        testDiv.style.left = '0';
        testDiv.style.width = '1px';
        testDiv.style.height = '1px';
        testDiv.style.zIndex = '-9999';
        testDiv.style.visibility = 'hidden';

        // Append to body to inherit styles
        document.body.appendChild(testDiv);

        // Get computed background color
        var computedStyle = window.getComputedStyle(testDiv);
        var bgColor = computedStyle.backgroundColor;

        // Clean up
        document.body.removeChild(testDiv);

        // Check if we got a valid color (not transparent)
        if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
          console.log('Visual background detection successful:', bgColor);
          return bgColor;
        }

        return null;
      } catch (e) {
        console.log('Visual detection failed:', e.message);
        return null;
      }
    }

    // Comprehensive site background database - expanded for better coverage
    function detectComprehensiveSiteBackground() {
      var referrer = document.referrer;
      console.log('Referrer URL:', referrer);

      if (!referrer) {
        console.log('No referrer available');
        return null;
      }

      try {
        var url = new URL(referrer);
        var hostname = url.hostname.toLowerCase();
        var pathname = url.pathname.toLowerCase();
        console.log('Parsed hostname:', hostname, 'pathname:', pathname);

        // Comprehensive database of sites and their typical background colors
        var siteDatabase = {
          // Note-taking & Documentation
          'notion.so': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(25, 25, 25)',
            patterns: {
              'desktop': 'rgb(255, 255, 255)',
              'mobile': 'rgb(255, 255, 255)'
            }
          },
          'notion.site': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(25, 25, 25)'
          },

          // Development & Code
          'github.com': {
            default: 'rgb(255, 255, 255)',
            dark: 'rgb(13, 17, 23)',
            patterns: {
              'repositories': 'rgb(255, 255, 255)',
              'issues': 'rgb(255, 255, 255)',
              'pulls': 'rgb(255, 255, 255)'
            }
          },
          'gitlab.com': 'rgb(255, 255, 255)',
          'bitbucket.org': 'rgb(255, 255, 255)',
          'stackoverflow.com': 'rgb(255, 255, 255)',
          'stackexchange.com': 'rgb(255, 255, 255)',

          // Writing & Blogging
          'medium.com': 'rgb(255, 255, 255)',
          'dev.to': 'rgb(255, 255, 255)',
          'hashnode.dev': 'rgb(255, 255, 255)',
          'ghost.org': 'rgb(255, 255, 255)',

          // Social & Community
          'twitter.com': 'rgb(255, 255, 255)',
          'linkedin.com': 'rgb(255, 255, 255)',
          'reddit.com': 'rgb(255, 255, 255)',
          'discord.com': 'rgb(54, 57, 63)',

          // Productivity & Business
          'trello.com': 'rgb(240, 240, 240)',
          'asana.com': 'rgb(255, 255, 255)',
          'monday.com': 'rgb(255, 255, 255)',
          'clickup.com': 'rgb(255, 255, 255)',
          'airtable.com': 'rgb(255, 255, 255)',

          // Design & Creative
          'figma.com': 'rgb(255, 255, 255)',
          'dribbble.com': 'rgb(255, 255, 255)',
          'behance.net': 'rgb(255, 255, 255)',
          'canva.com': 'rgb(255, 255, 255)',

          // Learning & Education
          'coursera.org': 'rgb(255, 255, 255)',
          'udemy.com': 'rgb(255, 255, 255)',
          'edx.org': 'rgb(255, 255, 255)',
          'khanacademy.org': 'rgb(255, 255, 255)',

          // News & Media
          'nytimes.com': 'rgb(255, 255, 255)',
          'theguardian.com': 'rgb(255, 255, 255)',
          'bbc.com': 'rgb(255, 255, 255)',
          'cnn.com': 'rgb(255, 255, 255)',

          // E-commerce
          'amazon.com': 'rgb(255, 255, 255)',
          'ebay.com': 'rgb(255, 255, 255)',
          'shopify.com': 'rgb(255, 255, 255)',

          // Cloud & Services
          'aws.amazon.com': 'rgb(255, 255, 255)',
          'azure.microsoft.com': 'rgb(255, 255, 255)',
          'cloud.google.com': 'rgb(255, 255, 255)',
          'digitalocean.com': 'rgb(255, 255, 255)',
          'vercel.com': 'rgb(255, 255, 255)',
          'netlify.com': 'rgb(255, 255, 255)',

          // Analytics & Marketing
          'google.com/analytics': 'rgb(255, 255, 255)',
          'mixpanel.com': 'rgb(255, 255, 255)',
          'segment.com': 'rgb(255, 255, 255)',
          'hubspot.com': 'rgb(255, 255, 255)',

          // Communication
          'slack.com': 'rgb(248, 249, 250)',
          'teams.microsoft.com': 'rgb(255, 255, 255)',
          'zoom.us': 'rgb(255, 255, 255)',
          'meet.google.com': 'rgb(255, 255, 255)',

          // File Storage
          'drive.google.com': 'rgb(255, 255, 255)',
          'dropbox.com': 'rgb(255, 255, 255)',
          'onedrive.live.com': 'rgb(255, 255, 255)',
          'box.com': 'rgb(255, 255, 255)',

          // Development Tools
          'codepen.io': 'rgb(255, 255, 255)',
          'jsfiddle.net': 'rgb(255, 255, 255)',
          'repl.it': 'rgb(255, 255, 255)',
          'codesandbox.io': 'rgb(255, 255, 255)',
          'glitch.com': 'rgb(255, 255, 255)',

          // Video & Streaming
          'youtube.com': 'rgb(255, 255, 255)',
          'vimeo.com': 'rgb(255, 255, 255)',
          'twitch.tv': 'rgb(15, 15, 15)',

          // Music & Audio
          'spotify.com': 'rgb(25, 20, 20)',
          'soundcloud.com': 'rgb(255, 85, 46)',
          'bandcamp.com': 'rgb(255, 255, 255)',

          // Health & Fitness
          'strava.com': 'rgb(255, 255, 255)',
          'myfitnesspal.com': 'rgb(255, 255, 255)',
          'fitbit.com': 'rgb(255, 255, 255)',

          // Finance
          'mint.com': 'rgb(255, 255, 255)',
          'personalcapital.com': 'rgb(255, 255, 255)',
          'ynab.com': 'rgb(255, 255, 255)',

          // Travel
          'airbnb.com': 'rgb(255, 255, 255)',
          'booking.com': 'rgb(255, 255, 255)',
          'expedia.com': 'rgb(255, 255, 255)',
          'kayak.com': 'rgb(255, 255, 255)',

          // Food & Cooking
          'allrecipes.com': 'rgb(255, 255, 255)',
          'foodnetwork.com': 'rgb(255, 255, 255)',
          'epicurious.com': 'rgb(255, 255, 255)',

          // Gaming
          'steam.com': 'rgb(23, 26, 33)',
          'epicgames.com': 'rgb(255, 255, 255)',
          'gog.com': 'rgb(255, 255, 255)',
          'itch.io': 'rgb(255, 255, 255)',

          // Science & Research
          'wikipedia.org': 'rgb(255, 255, 255)',
          'researchgate.net': 'rgb(255, 255, 255)',
          'academia.edu': 'rgb(255, 255, 255)',
          'arxiv.org': 'rgb(255, 255, 255)',

          // Government & Legal
          'usa.gov': 'rgb(255, 255, 255)',
          'gov.uk': 'rgb(255, 255, 255)',
          'whitehouse.gov': 'rgb(255, 255, 255)',

          // Dark theme sites
          'biznuts.github.io': 'rgb(25, 25, 25)', // Your specific case
          'github.io': 'rgb(25, 25, 25)', // GitHub Pages dark themes
        };

        // Check for exact hostname match first
        if (siteDatabase[hostname]) {
          var siteInfo = siteDatabase[hostname];

          // If it's an object with multiple options, choose based on context
          if (typeof siteInfo === 'object' && siteInfo.default) {
            // Check for dark theme indicators in URL
            if (pathname.includes('dark') || pathname.includes('night') ||
                document.cookie.includes('dark') || document.cookie.includes('theme=dark')) {
              return siteInfo.dark || siteInfo.default;
            }

            // Check for specific patterns
            if (siteInfo.patterns) {
              for (var pattern in siteInfo.patterns) {
                if (pathname.includes(pattern)) {
                  return siteInfo.patterns[pattern];
                }
              }
            }

            return siteInfo.default;
          }

          return siteInfo;
        }

        // Special case for biznuts.github.io - prioritize this match
        if (hostname === 'biznuts.github.io') {
          console.log('🎯 Detected biznuts.github.io, using dark theme background');
          return 'rgb(25, 25, 25)';
        }

        // Check for partial matches (e.g., subdomains)
        for (var site in siteDatabase) {
          if (hostname.includes(site) || site.includes(hostname)) {
            var siteInfo = siteDatabase[site];
            if (typeof siteInfo === 'object' && siteInfo.default) {
              return siteInfo.default;
            }
            return siteInfo;
          }
        }

        return null;
      } catch (e) {
        console.log('Error in comprehensive site detection:', e.message);
        return null;
      }
    }

    // PostMessage communication with parent window for background color
    function requestBackgroundFromParent() {
      try {
        // Send a request to parent window for background information
        var requestId = 'bg_request_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var request = {
          type: 'GET_BACKGROUND_COLOR',
          id: requestId,
          source: 'feedback_widget'
        };

        window.parent.postMessage(request, '*');

        // Set up a one-time listener for the response
        return new Promise(function(resolve) {
          var timeout = setTimeout(function() {
            window.removeEventListener('message', responseHandler);
            resolve(null);
          }, 1000); // 1 second timeout

          function responseHandler(event) {
            if (event.data && event.data.type === 'BACKGROUND_COLOR_RESPONSE' &&
                event.data.id === requestId) {
              clearTimeout(timeout);
              window.removeEventListener('message', responseHandler);
              resolve(event.data.backgroundColor);
            }
          }

          window.addEventListener('message', responseHandler);
        });
      } catch (e) {
        console.log('PostMessage communication failed:', e.message);
        return null;
      }
    }

    // CSS custom properties detection (fallback method)
    function detectCSSCustomProperties() {
      try {
        // Try to read CSS custom properties that might be inherited
        var rootStyles = window.getComputedStyle(document.documentElement);

        // Common CSS custom property names for backgrounds
        var bgProperties = [
          '--bg-color', '--background-color', '--bg-primary',
          '--color-background', '--surface-background',
          '--notion-bg-color', '--theme-bg-color'
        ];

        for (var i = 0; i < bgProperties.length; i++) {
          var propValue = rootStyles.getPropertyValue(bgProperties[i]);
          if (propValue && propValue !== '') {
            console.log('Found CSS custom property:', bgProperties[i], '=', propValue);
            return propValue;
          }
        }

        return null;
      } catch (e) {
        console.log('CSS custom properties detection failed:', e.message);
        return null;
      }
    }

    // Enhanced function to detect Notion theme colors (legacy compatibility)
    function detectNotionTheme() {
      var theme = {
        background: null,
        text: null,
        isDark: false
      };

      // Use the enhanced parent detection
      theme.background = getParentBackgroundColor();

      if (theme.background && theme.background !== 'transparent' && theme.background !== 'rgba(0, 0, 0, 0)') {
        var rgb = parseColorToRgb(theme.background);
        if (rgb) {
          var yiq = ((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000;
          theme.isDark = yiq < 128;
          theme.text = calculateOptimalTextColor(theme.background);
        }
      }

      return theme;
    }

    // Enhanced function to apply auto-contrast with improved color detection
    function applyAutoContrast() {
      var elements = document.querySelectorAll('.auto-contrast-text');
      var notionTheme = detectNotionTheme();

      elements.forEach(function (element) {
        var finalColor = null;

        // Priority 1: Use parent document background if available (for embedded widgets)
        if (element.classList.contains('notion-enhanced') && notionTheme.background) {
          finalColor = calculateOptimalTextColor(notionTheme.background);
          console.log('Using parent background - Background:', notionTheme.background, 'Text color:', finalColor);
        }

        // Priority 2: Use local background detection if no parent color available
        if (!finalColor) {
          var bgColor = findElementBackgroundColor(element);

          if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
            finalColor = calculateOptimalTextColor(bgColor);
            console.log('Using local background - Background:', bgColor, 'Text color:', finalColor);
          } else {
            // Priority 3: Use CSS custom properties if available
            finalColor = useCSSCustomProperties(element);
          }
        }

        // Priority 4: Final fallback - use a sensible default based on element class
        if (!finalColor) {
          finalColor = element.classList.contains('notion-enhanced') ?
            'rgba(255, 255, 255, 0.9)' : // Default for Notion themes
            'rgba(0, 0, 0, 0.8)';        // Default for other themes
          console.log('Using fallback color for element:', element.className, 'Color:', finalColor);
        }

        // Apply the determined color with high specificity
        if (finalColor) {
          element.style.setProperty('color', finalColor, 'important');
        }
      });
    }

    // Helper function to find the effective background color of an element
    function findElementBackgroundColor(element) {
      // Get the background color of the element itself
      var elementBgColor = window.getComputedStyle(element).backgroundColor;

      // If element has no background, check parent elements
      var bgColor = elementBgColor;
      if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent') {
        var parent = element.parentElement;
        var maxDepth = 10; // Prevent infinite loops
        var depth = 0;

        while (parent && depth < maxDepth && (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent')) {
          bgColor = window.getComputedStyle(parent).backgroundColor;
          parent = parent.parentElement;
          depth++;
        }
      }

      return bgColor;
    }

    // Helper function to use CSS custom properties if available
    function useCSSCustomProperties(element) {
      try {
        var computedStyle = window.getComputedStyle(element);
        var bgColor = computedStyle.backgroundColor;

        if (bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
          return calculateOptimalTextColor(bgColor);
        }

        // Check for CSS custom properties
        var customBg = computedStyle.getPropertyValue('--bg-color');
        if (customBg) {
          return calculateOptimalTextColor(customBg);
        }
      } catch (e) {
        console.log('Error accessing computed styles:', e.message);
      }

      return null;
    }

    // Listen for Notion theme changes via PostMessage API
    window.addEventListener('message', function(event) {
      // Verify origin for security (adjust as needed for Notion domains)
      if (event.origin.includes('notion.so') || event.origin.includes('notion.site')) {
        if (event.data && event.data.type === 'themeChange') {
          console.log('Notion theme change detected:', event.data);
          setTimeout(applyAutoContrast, 100);
        }
      }
    });

    // Apply auto-contrast when page loads
    document.addEventListener('DOMContentLoaded', function () {
      applyAutoContrast();
      setupEnhancedObserver(); // Use the enhanced observer instead
    });

    // Apply auto-contrast when Lyket widget loads (in case it changes colors)
    document.addEventListener('DOMNodeInserted', function () {
      setTimeout(applyAutoContrast, 100);
    });

    // Performance optimization: Cache computed values to avoid redundant calculations
    var colorCache = new Map();
    var lastParentBg = null;

    function getCachedOptimalColor(backgroundColor) {
      if (colorCache.has(backgroundColor)) {
        return colorCache.get(backgroundColor);
      }

      var optimalColor = calculateOptimalTextColor(backgroundColor);
      colorCache.set(backgroundColor, optimalColor);
      return optimalColor;
    }

    // Enhanced observer setup - works around cross-origin restrictions
    function setupEnhancedObserver() {
      try {
        // Method 1: Monitor our own document for style changes that might indicate parent changes
        var localObserver = new MutationObserver(function(mutations) {
          var shouldUpdate = false;

          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              shouldUpdate = true;
            }
            if (mutation.type === 'childList') {
              // Check if background-related elements were added/removed
              var hasBgElements = Array.from(mutation.addedNodes).some(function(node) {
                return node.nodeType === Node.ELEMENT_NODE &&
                       (node.style && node.style.backgroundColor) ||
                       node.classList && node.classList.contains('has-background');
              });
              if (hasBgElements) shouldUpdate = true;
            }
          });

          if (shouldUpdate) {
            console.log('Local style change detected, updating colors...');
            clearColorCache();
            setTimeout(applyAutoContrast, 100);
          }
        });

        localObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['style'],
          childList: true,
          subtree: true
        });

        // Method 2: Set up polling for visual background changes (fallback for cross-origin)
        var lastVisualBg = null;
        var pollInterval = setInterval(function() {
          try {
            var currentVisualBg = detectVisualBackground();
            if (currentVisualBg && currentVisualBg !== lastVisualBg) {
              console.log('Visual background change detected:', currentVisualBg);
              lastVisualBg = currentVisualBg;
              clearColorCache();
              applyAutoContrast();
            }
          } catch (e) {
            // Visual detection might fail in some browsers, that's okay
            console.log('Polling error (non-critical):', e.message);
          }
        }, 3000); // Poll every 3 seconds (less frequent to reduce noise)

        // Method 3: Listen for postMessage theme change notifications
        window.addEventListener('message', function(event) {
          if (event.data && event.data.type === 'themeChange') {
            console.log('Theme change notification received:', event.data);
            clearColorCache();
            setTimeout(applyAutoContrast, 100);
          }
        });

        console.log('Enhanced observer setup complete (cross-origin compatible)');
      } catch (e) {
        console.log('Could not set up enhanced observer:', e.message);
      }
    }

    function clearColorCache() {
      colorCache.clear();
      lastParentBg = null;
    }

    // Make enhanced functions globally available for testing and debugging
    window.testAutoContrast = applyAutoContrast;
    window.detectNotionTheme = detectNotionTheme;
    window.getParentBackgroundColor = getParentBackgroundColor;
    window.calculateOptimalTextColor = calculateOptimalTextColor;
    window.clearColorCache = clearColorCache;

    // Enhanced debugging function
    window.debugColorDetection = function() {
      console.log('=== Color Detection Debug Info ===');
      console.log('Parent background:', getParentBackgroundColor());
      console.log('Notion theme:', detectNotionTheme());
      console.log('Cache size:', colorCache.size);
      console.log('Available functions:', Object.keys(window).filter(k => k.includes('Color')));
    };
  </script>
</body>

</html>
